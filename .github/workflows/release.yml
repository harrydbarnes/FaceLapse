name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: gradle

    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    # In a real app, we would decode the keystore from secrets here.
    # For this task, we will build an unsigned release or debug APK if signing is not set up.
    # We'll assume we want to produce the artifact.

    - name: Build Release APK
      run: ./gradlew assembleRelease

    - name: Generate Release Notes
      id: release_notes
      run: |
        # Simple changelog generation based on commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          git log --pretty=format:"- %s" > RELEASE_NOTES.md
        else
          git log --pretty=format:"- %s" "$LAST_TAG"..HEAD > RELEASE_NOTES.md
        fi

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        body_path: RELEASE_NOTES.md
        files: |
          app/build/outputs/apk/release/app-release-unsigned.apk
          app/build/outputs/apk/debug/app-debug.apk
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  version-bump:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    outputs:
      new_tag: ${{ steps.bump.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Next Version
        id: bump
        run: |
          # Get latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          IFS='.' read -r major minor patch <<< "${LATEST_TAG#v}"

          # Check commit messages
          BUMP_MAJOR=false
          BUMP_MINOR=false
          BUMP_PATCH=false

          commits=$(git log $LATEST_TAG..HEAD --pretty=format:"%s")

          if echo "$commits" | grep -q "breaking"; then
            BUMP_MAJOR=true
          elif echo "$commits" | grep -q "feat"; then
            BUMP_MINOR=true
          else
            BUMP_PATCH=true
          fi

          if [ "$BUMP_MAJOR" = true ]; then
            major=$((major + 1))
            minor=0
            patch=0
          elif [ "$BUMP_MINOR" = true ]; then
            minor=$((minor + 1))
            patch=0
          else
            patch=$((patch + 1))
          fi

          NEW_TAG="v$major.$minor.$patch"
          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Determined new version: $NEW_TAG"

      # Note: We are not pushing the tag back automatically to avoid infinite loops
      # or permissions issues in this simulated environment, but normally we would:
      # - git tag $NEW_TAG
      # - git push origin $NEW_TAG

      # Uncommenting for "completeness" as requested, assuming tokens are set up
      # - name: Push Tag
      #   run: |
      #     git tag ${{ steps.bump.outputs.new_tag }}
      #     git push origin ${{ steps.bump.outputs.new_tag }}
